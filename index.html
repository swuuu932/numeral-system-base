<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>진법 변환 수학 시뮬레이터</title>
    <style>
        :root {
            --bg: #0f172a;
            --card: #1e293b;
            --text: #f1f5f9;
            --primary: #3b82f6;
            --fixed: #10b981;
            --cycle: #f59e0b;
            --divergent: #ef4444;
            --nav-bg: #1e293b;
        }

        body {
            font-family: 'Pretendard', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* SPA Navigation */
        nav {
            background-color: var(--nav-bg);
            padding: 0.5rem 1rem;
            display: flex;
            gap: 1rem;
            border-bottom: 1px solid #334155;
            z-index: 100;
        }

        nav button {
            background: transparent;
            color: #94a3b8;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        nav button.active {
            color: white;
            background: #334155;
        }

        /* View Layout */
        .view-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .view {
            display: none;
            width: 100%;
            height: 100%;
        }

        .view.active {
            display: flex;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 400px;
            background-color: var(--card);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 10;
        }

        h1 { font-size: 1.75rem; margin: 0; color: var(--primary); }

        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        label { font-size: 1.1rem; color: #94a3b8; }
        input {
            background: #0f172a;
            border: 1px solid #334155;
            padding: 0.8rem;
            border-radius: 6px;
            color: white;
            font-size: 1.2rem;
        }

        .action-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 1rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: filter 0.2s;
        }
        .action-btn:hover { filter: brightness(1.2); }

        .info-panel {
            margin-top: auto;
            padding: 1.2rem;
            background: #0f172a;
            border-radius: 8px;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        /* Canvas Areas */
        .main-content {
            flex: 1;
            position: relative;
        }

        canvas { width: 100%; height: 100%; display: block; }

        .legend {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            background: rgba(30, 41, 59, 0.8);
            padding: 1.2rem;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .legend-item { display: flex; align-items: center; gap: 0.75rem; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }

        /* Range Analysis Specific */
        #analysis-progress {
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
        }
    </style>
</head>
<body>

    <nav>
        <button id="nav-vis" class="active">시각화</button>
        <button id="nav-analysis">범위 분석</button>
    </nav>

    <div class="view-container">
        <!-- 화면 1: 시각화 -->
        <div id="view-vis" class="view active">
            <aside class="sidebar">
                <h1>상태 전이 그래프</h1>
                <p style="font-size: 1.1rem; color: #94a3b8; margin: 0;">
                    1. 자리수 합 b 계산 -> N을 b진법 변환 -> 재해석
                </p>
                <div class="control-group">
                    <label for="startN">시작 정수 N</label>
                    <input type="text" id="startN" value="123456789">
                </div>
                <div class="control-group">
                    <label for="maxIter">최대 반복 횟수</label>
                    <input type="number" id="maxIter" value="30" min="1" max="100">
                </div>
                <button id="runBtn" class="action-btn">시뮬레이션 시작</button>
                <div id="info-panel" class="info-panel" style="display:none">
                    <h3 style="margin-top: 0; font-size: 1.25rem;">노드 상세 정보</h3>
                    <div id="node-details"></div>
                </div>
            </aside>
            <main class="main-content">
                <canvas id="graphCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="dot" style="background: var(--primary);"></div> 일반 노드</div>
                    <div class="legend-item"><div class="dot" style="background: var(--cycle);"></div> 사이클</div>
                    <div class="legend-item"><div class="dot" style="background: var(--fixed);"></div> 고정점</div>
                </div>
            </main>
        </div>

        <!-- 화면 2: 범위 분석 -->
        <div id="view-analysis" class="view">
            <aside class="sidebar">
                <h1>범위 분석</h1>
                <p style="font-size: 1.1rem; color: #94a3b8; margin: 0;">
                    특정 범위의 모든 정수에 대해 최종 상태(고정점, 사이클, 발산)를 분류합니다.
                </p>
                <div class="control-group">
                    <label for="minStart">최소 시작값</label>
                    <input type="text" id="minStart" value="1">
                </div>
                <div class="control-group">
                    <label for="maxStart">최대 시작값</label>
                    <input type="text" id="maxStart" value="1000">
                </div>
                <div class="control-group">
                    <label for="rangeIter">최대 반복 횟수</label>
                    <input type="number" id="rangeIter" value="50" min="1" max="500">
                </div>
                <button id="analysisBtn" class="action-btn">분석 실행</button>
                <div id="analysis-progress">대기 중...</div>
                <div class="info-panel" style="margin-top: 1rem;">
                    <b>A. Fixed Point:</b> N=f(N) 도달<br>
                    <b>B. Cycle:</b> 이전 값 재등장<br>
                    <b>C. Divergent:</b> 10,000자 초과 또는 반복 제한
                </div>
            </aside>
            <main class="main-content">
                <canvas id="analysisCanvas"></canvas>
            </main>
        </div>
    </div>

<script>
    /**
     * 공통 시스템 연산 로직
     */
    function getDigitSum(n) {
        return n.toString().split('').reduce((acc, char) => acc + BigInt(char), 0n);
    }

    function toBaseBString(n, b) {
        if (b <= 1n) return n.toString();
        if (n === 0n) return "0";
        let digits = [];
        let tempN = n;
        while (tempN > 0n) {
            digits.push(tempN % b);
            tempN = tempN / b;
        }
        return digits.reverse().join('');
    }

    function getNextState(n) {
        const b = getDigitSum(n);
        const bString = toBaseBString(n, b);
        const nextN = BigInt(bString);
        return { value: n, b, bString, next: nextN };
    }

    /**
     * SPA 화면 전환 로직
     */
    const navVis = document.getElementById('nav-vis');
    const navAnalysis = document.getElementById('nav-analysis');
    const viewVis = document.getElementById('view-vis');
    const viewAnalysis = document.getElementById('view-analysis');

    function switchView(viewName) {
        if (viewName === 'vis') {
            navVis.classList.add('active');
            navAnalysis.classList.remove('active');
            viewVis.classList.add('active');
            viewAnalysis.classList.remove('active');
            startVisAnimation();
        } else {
            navVis.classList.remove('active');
            navAnalysis.classList.add('active');
            viewVis.classList.remove('active');
            viewAnalysis.classList.add('active');
            stopVisAnimation();
        }
    }

    navVis.addEventListener('click', () => switchView('vis'));
    navAnalysis.addEventListener('click', () => switchView('analysis'));

    /**
     * [화면 1] 시각화 로직
     */
    const graphCanvas = document.getElementById('graphCanvas');
    const gCtx = graphCanvas.getContext('2d');
    const NODE_RADIUS = 35;
    let nodes = [];
    let edges = [];
    let selectedNode = null;
    let draggedNode = null;
    let animationId = null;
    let simulationAlpha = 1.0;

    function generateGraphData() {
        nodes = [];
        edges = [];
        simulationAlpha = 1.0;
        const startN = BigInt(document.getElementById('startN').value.trim() || "0");
        const maxIter = parseInt(document.getElementById('maxIter').value);
        let currentN = startN;
        const visitedMap = new Map();
        const sequence = [];

        for (let i = 0; i < maxIter; i++) {
            if (visitedMap.has(currentN)) {
                markCycle(sequence, visitedMap.get(currentN));
                break;
            }
            const state = getNextState(currentN);
            visitedMap.set(currentN, i);
            sequence.push(state);
            const node = {
                id: currentN.toString(), value: currentN, b: state.b, bString: state.bString,
                nextValue: state.next, x: graphCanvas.width / 2 + (Math.random() - 0.5) * 100,
                y: graphCanvas.height / 2 + (Math.random() - 0.5) * 100, vx: 0, vy: 0, type: 'normal'
            };
            if (state.value === state.next) node.type = 'fixed';
            nodes.push(node);
            edges.push({ source: currentN.toString(), target: state.next.toString() });
            if (node.type === 'fixed') break;
            currentN = state.next;
        }
    }

    function markCycle(sequence, startIndex) {
        for (let i = startIndex; i < sequence.length; i++) {
            const node = nodes.find(n => n.id === sequence[i].value.toString());
            if (node && node.type !== 'fixed') node.type = 'cycle';
        }
    }

    function updatePhysics() {
        if (simulationAlpha < 0.005) return false; // 시뮬레이션 온도 낮으면 물리 중단
        const repulsion = 5000 * simulationAlpha;
        const springLength = 160;
        const springStrength = 0.08 * simulationAlpha;
        const friction = 0.85;

        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const n1 = nodes[i], n2 = nodes[j];
                const dx = n2.x - n1.x, dy = n2.y - n1.y, d2 = dx*dx + dy*dy + 0.1, d = Math.sqrt(d2);
                const f = repulsion / d2;
                n1.vx -= (dx/d)*f; n1.vy -= (dy/d)*f; n2.vx += (dx/d)*f; n2.vy += (dy/d)*f;
            }
        }
        edges.forEach(e => {
            const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target);
            if (!s || !t || s === t) return;
            const dx = t.x - s.x, dy = t.y - s.y, d = Math.sqrt(dx*dx + dy*dy) || 0.1;
            const f = (d - springLength) * springStrength;
            s.vx += (dx/d)*f; s.vy += (dy/d)*f; t.vx -= (dx/d)*f; t.vy -= (dy/d)*f;
        });
        nodes.forEach(n => {
            if (n === draggedNode) return;
            n.vx += (graphCanvas.width/2 - n.x) * 0.005 * simulationAlpha;
            n.vy += (graphCanvas.height/2 - n.y) * 0.005 * simulationAlpha;
            n.vx *= friction; n.vy *= friction;
            n.x += n.vx; n.y += n.vy;
        });
        simulationAlpha *= 0.99;
        return true;
    }

    function drawVis() {
        gCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
        const isMoving = updatePhysics();
        edges.forEach(e => {
            const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target);
            if (!s || !t || s === t) return;
            const angle = Math.atan2(t.y - s.y, t.x - s.x);
            const tx = t.x - NODE_RADIUS * Math.cos(angle), ty = t.y - NODE_RADIUS * Math.sin(angle);
            const sx = s.x + NODE_RADIUS * Math.cos(angle), sy = s.y + NODE_RADIUS * Math.sin(angle);
            gCtx.beginPath(); gCtx.moveTo(sx, sy); gCtx.lineTo(tx, ty);
            gCtx.strokeStyle = 'rgba(100, 116, 139, 0.5)'; gCtx.lineWidth = 3; gCtx.stroke();
            gCtx.beginPath(); gCtx.moveTo(tx, ty);
            gCtx.lineTo(tx - 15 * Math.cos(angle - Math.PI/6), ty - 15 * Math.sin(angle - Math.PI/6));
            gCtx.lineTo(tx - 15 * Math.cos(angle + Math.PI/6), ty - 15 * Math.sin(angle + Math.PI/6));
            gCtx.closePath(); gCtx.fillStyle = 'rgba(100, 116, 139, 0.8)'; gCtx.fill();
        });

        const time = Date.now() / 1000;
        nodes.forEach(n => {
            gCtx.save();
            let color = '#3b82f6'; if (n.type === 'fixed') color = '#10b981'; else if (n.type === 'cycle') color = '#f59e0b';
            gCtx.shadowBlur = 15 + Math.sin(time*3)*5; gCtx.shadowColor = color;
            let scale = 1.0;
            // 시뮬레이션 중이거나 드래그 중일 때만 애니메이션 효과
            if (isMoving || draggedNode || n === selectedNode) scale = 1.0 + Math.sin(time*4)*0.03;
            gCtx.beginPath(); gCtx.arc(n.x, n.y, NODE_RADIUS*scale, 0, Math.PI*2);
            if (selectedNode === n) { gCtx.strokeStyle = 'white'; gCtx.lineWidth = 4; gCtx.stroke(); }
            gCtx.fillStyle = color; gCtx.fill();
            gCtx.shadowBlur = 0; gCtx.fillStyle = 'white'; gCtx.font = 'bold 14px monospace'; gCtx.textAlign = 'center';
            const dv = n.id.length > 7 ? n.id.substring(0,6) + '..' : n.id;
            gCtx.fillText(dv, n.x, n.y + 5); gCtx.restore();
        });

        // 물리 연산이 멈추고 드래그 중이 아니면 루프 중단 (전력 절약 및 고정)
        if (isMoving || draggedNode) {
            animationId = requestAnimationFrame(drawVis);
        } else {
            animationId = null;
        }
    }

    function startVisAnimation() {
        if (!animationId) drawVis();
    }
    function stopVisAnimation() {
        if (animationId) cancelAnimationFrame(animationId);
        animationId = null;
    }

    document.getElementById('runBtn').addEventListener('click', () => {
        stopVisAnimation();
        generateGraphData();
        startVisAnimation();
    });

    graphCanvas.addEventListener('mousedown', (e) => {
        const rect = graphCanvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const found = nodes.find(n => Math.sqrt((n.x-mx)**2 + (n.y-my)**2) < NODE_RADIUS);
        if (found) {
            draggedNode = found; selectedNode = found; simulationAlpha = 0.5;
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('node-details').innerHTML = `<b>값:</b> ${found.value}<br><b>진법 b:</b> ${found.b}<br><b>다음값:</b> ${found.nextValue}`;
            startVisAnimation();
        } else { selectedNode = null; document.getElementById('info-panel').style.display = 'none'; }
    });
    window.addEventListener('mousemove', (e) => { if (draggedNode) { const r = graphCanvas.getBoundingClientRect(); draggedNode.x = e.clientX-r.left; draggedNode.y = e.clientY-r.top; simulationAlpha = 0.2; } });
    window.addEventListener('mouseup', () => draggedNode = null);

    /**
     * [화면 2] 범위 분석 로직
     */
    const analysisCanvas = document.getElementById('analysisCanvas');
    const aCtx = analysisCanvas.getContext('2d');
    const analysisProgress = document.getElementById('analysis-progress');
    let analysisData = { fixed: 0, cycle: 0, divergent: 0 };

    function classifyN(n, maxIter) {
        let current = n;
        const history = new Set();
        for (let i = 0; i < maxIter; i++) {
            const next = getNextState(current).next;
            if (next === current) return 'fixed';
            if (history.has(next)) return 'cycle';
            if (next.toString().length > 10000) return 'divergent';
            history.add(next);
            current = next;
        }
        return 'divergent'; // 제한 횟수 초과
    }

    async function runRangeAnalysis() {
        const min = BigInt(document.getElementById('minStart').value);
        const max = BigInt(document.getElementById('maxStart').value);
        const iter = parseInt(document.getElementById('rangeIter').value);
        
        analysisData = { fixed: 0, cycle: 0, divergent: 0 };
        const total = Number(max - min + 1n);
        let processed = 0;

        const CHUNK_SIZE = 50; // 한 번에 처리할 양

        async function processChunk(currentN) {
            for (let i = 0; i < CHUNK_SIZE && currentN <= max; i++) {
                const result = classifyN(currentN, iter);
                analysisData[result]++;
                currentN++;
                processed++;
            }

            // UI 업데이트
            analysisProgress.textContent = `진행률: ${Math.round((processed / total) * 100)}% (${processed}/${total})`;
            drawAnalysisChart();

            if (currentN <= max) {
                // 다음 덩어리를 비동기로 실행하여 메인 스레드 확보
                setTimeout(() => processChunk(currentN), 0);
            } else {
                analysisProgress.textContent = `분석 완료! (총 ${total}개)`;
            }
        }

        processChunk(min);
    }

    function drawAnalysisChart() {
        const rect = analysisCanvas.getBoundingClientRect();
        analysisCanvas.width = rect.width;
        analysisCanvas.height = rect.height;
        aCtx.clearRect(0, 0, analysisCanvas.width, analysisCanvas.height);

        const categories = [
            { key: 'fixed', label: 'Fixed Point', color: '#10b981' },
            { key: 'cycle', label: 'Cycle', color: '#f59e0b' },
            { key: 'divergent', label: 'Divergent', color: '#ef4444' }
        ];

        const total = analysisData.fixed + analysisData.cycle + analysisData.divergent || 1;
        const barWidth = analysisCanvas.width * 0.15;
        const chartBottom = analysisCanvas.height * 0.8;
        const maxVal = Math.max(...categories.map(c => analysisData[c.key]), 1);

        categories.forEach((cat, i) => {
            const val = analysisData[cat.key];
            const barHeight = (val / maxVal) * (analysisCanvas.height * 0.6);
            const x = (analysisCanvas.width / 4) * (i + 1) - barWidth / 2;
            const y = chartBottom - barHeight;

            // 막대 그리기
            aCtx.fillStyle = cat.color;
            aCtx.fillRect(x, y, barWidth, barHeight);

            // 레이블 및 수치
            aCtx.fillStyle = 'white';
            aCtx.font = 'bold 1.2rem Pretendard';
            aCtx.textAlign = 'center';
            aCtx.fillText(val, x + barWidth/2, y - 15);
            aCtx.fillText(cat.label, x + barWidth/2, chartBottom + 30);
        });
    }

    document.getElementById('analysisBtn').addEventListener('click', runRangeAnalysis);

    window.addEventListener('resize', () => {
        const r = graphCanvas.parentElement.getBoundingClientRect();
        graphCanvas.width = r.width; graphCanvas.height = r.height;
        drawAnalysisChart();
    });

    window.onload = () => {
        const r = graphCanvas.parentElement.getBoundingClientRect();
        graphCanvas.width = r.width; graphCanvas.height = r.height;
        generateGraphData();
        startVisAnimation();
    };
</script>
</body>
</html>
