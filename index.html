<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>진법 변환 상태 전이 그래프 시뮬레이션</title>
    <style>
        :root {
            --bg: #0f172a;
            --card: #1e293b;
            --text: #f1f5f9;
            --primary: #3b82f6;
            --fixed: #10b981;
            --cycle: #f59e0b;
        }

        body {
            font-family: 'Pretendard', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 400px;
            background-color: var(--card);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 10;
        }

        h1 { font-size: 1.75rem; margin: 0; color: var(--primary); }

        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        label { font-size: 1.1rem; color: #94a3b8; }
        input {
            background: #0f172a;
            border: 1px solid #334155;
            padding: 0.8rem;
            border-radius: 6px;
            color: white;
            font-size: 1.2rem;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 1rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: filter 0.2s;
        }
        button:hover { filter: brightness(1.2); }

        #info-panel {
            margin-top: auto;
            padding: 1.2rem;
            background: #0f172a;
            border-radius: 8px;
            font-size: 1.1rem;
            line-height: 1.6;
            display: none;
        }

        #info-panel b { color: var(--primary); }

        #canvas-container {
            flex: 1;
            position: relative;
            cursor: grab;
        }

        #canvas-container:active { cursor: grabbing; }

        canvas { width: 100%; height: 100%; display: block; }

        .legend {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            background: rgba(30, 41, 59, 0.8);
            padding: 1.2rem;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .legend-item { display: flex; align-items: center; gap: 0.75rem; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
    </style>
</head>
<body>

    <aside id="sidebar">
        <h1>상태 전이 그래프</h1>
        <p style="font-size: 1.1rem; color: #94a3b8; margin: 0;">
            1. 자리수 합 b 계산<br>
            2. N을 b진법으로 변환<br>
            3. 결과를 10진수로 재해석
        </p>

        <div class="control-group">
            <label for="startN">시작 정수 N</label>
            <input type="text" id="startN" value="123456789">
        </div>

        <div class="control-group">
            <label for="maxIter">최대 반복 횟수</label>
            <input type="number" id="maxIter" value="30" min="1" max="100">
        </div>

        <button id="runBtn">시뮬레이션 시작</button>

        <div id="info-panel">
            <h3 style="margin-top: 0; font-size: 1.25rem;">노드 상세 정보</h3>
            <div id="node-details"></div>
        </div>
    </aside>

    <main id="canvas-container">
        <canvas id="graphCanvas"></canvas>
        <div class="legend">
            <div class="legend-item"><div class="dot" style="background: var(--primary);"></div> 일반 노드</div>
            <div class="legend-item"><div class="dot" style="background: var(--cycle);"></div> 사이클</div>
            <div class="legend-item"><div class="dot" style="background: var(--fixed);"></div> 고정점</div>
        </div>
    </main>

<script>
    /**
     * 상태 전이 시스템 로직 및 시각화 엔진
     */

    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const runBtn = document.getElementById('runBtn');
    const infoPanel = document.getElementById('info-panel');
    const nodeDetails = document.getElementById('node-details');

    const NODE_RADIUS = 35;
    let nodes = [];
    let edges = [];
    let selectedNode = null;
    let draggedNode = null;
    let animationId = null;
    let simulationAlpha = 1.0; // 시뮬레이션 온도 (점점 낮아짐)

    // 1. 시스템 연산 로직
    function getDigitSum(n) {
        return n.toString().split('').reduce((acc, char) => acc + BigInt(char), 0n);
    }

    function toBaseBString(n, b) {
        if (b <= 1n) return n.toString();
        if (n === 0n) return "0";
        let digits = [];
        let tempN = n;
        while (tempN > 0n) {
            digits.push(tempN % b);
            tempN = tempN / b;
        }
        return digits.reverse().join('');
    }

    function getNextState(n) {
        const b = getDigitSum(n);
        const bString = toBaseBString(n, b);
        const nextN = BigInt(bString);
        return { value: n, b, bString, next: nextN };
    }

    // 2. 그래프 데이터 생성
    function generateGraphData() {
        nodes = [];
        edges = [];
        simulationAlpha = 1.0; // 시뮬레이션 리셋
        const startN = BigInt(document.getElementById('startN').value.trim() || "0");
        const maxIter = parseInt(document.getElementById('maxIter').value);

        let currentN = startN;
        const visitedMap = new Map();
        const sequence = [];

        for (let i = 0; i < maxIter; i++) {
            if (visitedMap.has(currentN)) {
                const cycleStartIndex = visitedMap.get(currentN);
                markCycle(sequence, cycleStartIndex);
                break;
            }

            const state = getNextState(currentN);
            visitedMap.set(currentN, i);
            sequence.push(state);

            const node = {
                id: currentN.toString(),
                value: currentN,
                b: state.b,
                bString: state.bString,
                nextValue: state.next,
                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                vx: 0,
                vy: 0,
                type: 'normal'
            };

            if (state.value === state.next) node.type = 'fixed';
            nodes.push(node);
            edges.push({ source: currentN.toString(), target: state.next.toString() });

            if (node.type === 'fixed') break;
            currentN = state.next;
        }
    }

    function markCycle(sequence, startIndex) {
        for (let i = startIndex; i < sequence.length; i++) {
            const valStr = sequence[i].value.toString();
            const node = nodes.find(n => n.id === valStr);
            if (node && node.type !== 'fixed') node.type = 'cycle';
        }
    }

    // 3. Force-Directed Layout Simulation (Stable)
    function updatePhysics() {
        if (simulationAlpha < 0.01) return; // 에너지가 낮으면 계산 중단

        const repulsion = 5000 * simulationAlpha;
        const springLength = 160;
        const springStrength = 0.08 * simulationAlpha;
        const friction = 0.85;

        // 노드 간 반발력
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const n1 = nodes[i];
                const n2 = nodes[j];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const distSq = dx * dx + dy * dy + 0.1;
                const dist = Math.sqrt(distSq);
                const force = repulsion / distSq;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                n1.vx -= fx; n1.vy -= fy;
                n2.vx += fx; n2.vy += fy;
            }
        }

        // 간선 인력
        edges.forEach(edge => {
            const source = nodes.find(n => n.id === edge.source);
            const target = nodes.find(n => n.id === edge.target);
            if (!source || !target || source === target) return;

            const dx = target.x - source.x;
            const dy = target.y - source.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
            const force = (dist - springLength) * springStrength;
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;
            source.vx += fx; source.vy += fy;
            target.vx -= fx; target.vy -= fy;
        });

        // 중심 중력 및 업데이트
        nodes.forEach(n => {
            if (n === draggedNode) return;

            const dx = canvas.width / 2 - n.x;
            const dy = canvas.height / 2 - n.y;
            n.vx += dx * 0.005 * simulationAlpha;
            n.vy += dy * 0.005 * simulationAlpha;

            n.vx *= friction;
            n.vy *= friction;
            n.x += n.vx;
            n.y += n.vy;
        });

        simulationAlpha *= 0.992; // 점진적 쿨링
    }

    // 4. Rendering with Effects
    function drawArrow(x1, y1, x2, y2) {
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const targetX = x2 - NODE_RADIUS * Math.cos(angle);
        const targetY = y2 - NODE_RADIUS * Math.sin(angle);
        const sourceX = x1 + NODE_RADIUS * Math.cos(angle);
        const sourceY = y1 + NODE_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(sourceX, sourceY);
        ctx.lineTo(targetX, targetY);
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.5)';
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(targetX, targetY);
        ctx.lineTo(targetX - headlen * Math.cos(angle - Math.PI / 6), targetY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(targetX - headlen * Math.cos(angle + Math.PI / 6), targetY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fillStyle = 'rgba(100, 116, 139, 0.8)';
        ctx.fill();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updatePhysics();

        // 배경 연결선
        edges.forEach(edge => {
            const source = nodes.find(n => n.id === edge.source);
            const target = nodes.find(n => n.id === edge.target);
            if (source && target && source !== target) {
                drawArrow(source.x, source.y, target.x, target.y);
            }
        });

        const time = Date.now() / 1000;

        // 노드
        nodes.forEach(node => {
            ctx.save();
            
            let color = '#3b82f6';
            if (node.type === 'fixed') color = '#10b981';
            else if (node.type === 'cycle') color = '#f59e0b';
            
            // 글로우 효과
            ctx.shadowBlur = 15 + Math.sin(time * 3) * 5;
            ctx.shadowColor = color;

            // 맥동 효과 (사이클이나 선택된 노드)
            let scale = 1.0;
            if (node.type === 'cycle' || node.type === 'fixed' || node === selectedNode) {
                scale = 1.0 + Math.sin(time * 4) * 0.05;
            }

            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS * scale, 0, Math.PI * 2);
            
            if (selectedNode === node) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            ctx.fillStyle = color;
            ctx.fill();

            // 텍스트
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            const displayVal = node.id.length > 7 ? node.id.substring(0, 6) + '..' : node.id;
            ctx.fillText(displayVal, node.x, node.y + 5);
            
            ctx.restore();
        });

        animationId = requestAnimationFrame(draw);
    }

    // 5. Interaction (Drag & Click)
    function handleResize() {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const found = nodes.find(n => {
            const dist = Math.sqrt((n.x - mouseX)**2 + (n.y - mouseY)**2);
            return dist < NODE_RADIUS;
        });

        if (found) {
            draggedNode = found;
            selectedNode = found;
            simulationAlpha = 0.5; // 드래그 시 약간의 물리 효과 재활성화
            
            infoPanel.style.display = 'block';
            nodeDetails.innerHTML = `
                <b>현재값:</b> ${found.value.toString()}<br>
                <b>자리수 합 (b):</b> ${found.b.toString()}<br>
                <b>b진법 문자열:</b> ${found.bString}<br>
                <b>다음값:</b> ${found.nextValue.toString()}<br>
                <b>유형:</b> ${found.type.toUpperCase()}
            `;
        } else {
            selectedNode = null;
            infoPanel.style.display = 'none';
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (draggedNode) {
            const rect = canvas.getBoundingClientRect();
            draggedNode.x = e.clientX - rect.left;
            draggedNode.y = e.clientY - rect.top;
            simulationAlpha = Math.max(simulationAlpha, 0.2); // 움직임 유지
        }
    });

    window.addEventListener('mouseup', () => {
        draggedNode = null;
    });

    runBtn.addEventListener('click', () => {
        if (animationId) cancelAnimationFrame(animationId);
        generateGraphData();
        draw();
    });

    window.addEventListener('resize', handleResize);
    handleResize();
    generateGraphData();
    draw();
</script>
</body>
</html>
