<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>진법 변환 수학 시뮬레이터 (Ultimate)</title>
    <style>
        :root {
            --bg: #0f172a;
            --card: #1e293b;
            --text: #f1f5f9;
            --primary: #3b82f6;
            --fixed: #10b981;
            --cycle: #f59e0b;
            --divergent: #ef4444;
            --nav-bg: #1e293b;
        }

        body {
            font-family: 'Pretendard', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        nav {
            background-color: var(--nav-bg);
            padding: 0.5rem 1rem;
            display: flex;
            gap: 1rem;
            border-bottom: 1px solid #334155;
            z-index: 100;
        }

        nav button {
            background: transparent;
            color: #94a3b8;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        nav button.active { color: white; background: #334155; }

        .view-container { flex: 1; display: flex; position: relative; overflow: hidden; }
        .view { display: none; width: 100%; height: 100%; overflow: hidden; }
        .view.active { display: flex; }

        /* Sidebar Styles */
        .sidebar {
            width: 400px;
            background-color: var(--card);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .action-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 1rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: filter 0.2s;
        }
        .action-btn:hover { filter: brightness(1.2); }

        .main-content { flex: 1; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }

        /* Shared List Styles */
        .scroll-view { flex-direction: column; overflow-y: auto; padding: 2rem; background: var(--bg); width: 100%; }
        .header-row { display: flex; align-items: center; gap: 2rem; margin-bottom: 2rem; }
        .back-btn { background: #334155; color: white; border: none; padding: 0.5rem 1.5rem; border-radius: 6px; cursor: pointer; }
        
        .result-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 1.5rem; padding-bottom: 4rem; }
        .result-card { background: var(--card); padding: 1.5rem; border-radius: 12px; border-left: 6px solid #ccc; position: relative; }
        
        .result-card.fixed { border-left-color: var(--fixed); }
        .result-card.cycle { border-left-color: var(--cycle); }
        .result-card.divergent { border-left-color: var(--divergent); }
        
        .result-card h4 { margin: 0 0 0.5rem 0; color: var(--primary); font-size: 1.2rem; }
        .result-card p { margin: 0.4rem 0; font-size: 1rem; color: #cbd5e1; line-height: 1.4; }
        .result-card .stat-label { font-size: 0.85rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; }
        .result-card .val { font-family: monospace; color: white; background: #0f172a; padding: 2px 6px; border-radius: 4px; word-break: break-all; }

        /* History Specific */
        .history-card { border-left: 6px solid var(--primary); }
        .history-summary { display: flex; justify-content: space-between; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #334155; }
        .summary-item { text-align: center; }
        .summary-item .num { display: block; font-size: 1.25rem; font-weight: bold; }

        .delete-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(239, 68, 68, 0.1);
            color: var(--divergent);
            border: 1px solid var(--divergent);
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .delete-btn:hover { background: var(--divergent); color: white; }

        /* UI Elements */
        h1 { font-size: 1.75rem; margin: 0; color: var(--primary); }
        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        label { font-size: 1.1rem; color: #94a3b8; }
        input { background: #0f172a; border: 1px solid #334155; padding: 0.8rem; border-radius: 6px; color: white; font-size: 1.2rem; }
        .info-panel { margin-top: auto; padding: 1.2rem; background: #0f172a; border-radius: 8px; font-size: 1.1rem; line-height: 1.6; }
        .legend { position: absolute; bottom: 2rem; right: 2rem; background: rgba(30, 41, 59, 0.8); padding: 1.2rem; border-radius: 8px; backdrop-filter: blur(4px); font-size: 1.1rem; display: flex; flex-direction: column; gap: 0.75rem; }
        .legend-item { display: flex; align-items: center; gap: 0.75rem; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        #analysis-progress { margin-top: 1rem; font-size: 1.2rem; font-weight: bold; color: var(--primary); }
    </style>
</head>
<body>

    <nav id="main-nav">
        <button id="nav-vis" class="active">시각화</button>
        <button id="nav-analysis">범위 분석</button>
        <button id="nav-history">분석 기록</button>
    </nav>

    <div class="view-container">
        <!-- 화면 1: 시각화 -->
        <div id="view-vis" class="view active">
            <aside class="sidebar">
                <h1>상태 전이 그래프</h1>
                <p style="font-size: 1.1rem; color: #94a3b8; margin: 0;">1. 자리수 합 b 계산 -> N을 b진법 변환 -> 재해석</p>
                <div class="control-group"><label for="startN">시작 정수 N</label><input type="text" id="startN" value="123456789"></div>
                <div class="control-group"><label for="maxIter">최대 반복 횟수</label><input type="number" id="maxIter" value="30" min="1" max="100"></div>
                <button id="runBtn" class="action-btn">시뮬레이션 시작</button>
                <div id="info-panel" class="info-panel" style="display:none">
                    <h3 style="margin: 0; font-size: 1.25rem;">노드 상세 정보</h3>
                    <div id="node-details"></div>
                </div>
            </aside>
            <main class="main-content">
                <canvas id="graphCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="dot" style="background: var(--primary);"></div> 일반 노드</div>
                    <div class="legend-item"><div class="dot" style="background: var(--cycle);"></div> 사이클</div>
                    <div class="legend-item"><div class="dot" style="background: var(--fixed);"></div> 고정점</div>
                </div>
            </main>
        </div>

        <!-- 화면 2: 범위 분석 -->
        <div id="view-analysis" class="view">
            <aside class="sidebar">
                <h1>범위 분석</h1>
                <p style="font-size: 1.1rem; color: #94a3b8; margin: 0;">분석 결과 하단의 글자를 클릭하여 상세 목록을 확인하세요.</p>
                <div class="control-group"><label for="minStart">최소 시작값</label><input type="text" id="minStart" value="1"></div>
                <div class="control-group"><label for="maxStart">최대 시작값</label><input type="text" id="maxStart" value="1000"></div>
                <div class="control-group"><label for="rangeIter">최대 반복 횟수</label><input type="number" id="rangeIter" value="50" min="1" max="500"></div>
                <button id="analysisBtn" class="action-btn">분석 실행</button>
                <div id="analysis-progress">대기 중...</div>
                <div class="info-panel"><b>A. Fixed Point:</b> N=f(N) 도달<br><b>B. Cycle:</b> 이전 값 재등장<br><b>C. Divergent:</b> 10,000자 초과/제한</div>
            </aside>
            <main class="main-content"><canvas id="analysisCanvas"></canvas></main>
        </div>

        <!-- 화면 3: 상세 결과 -->
        <div id="view-details" class="view scroll-view">
            <div class="header-row">
                <button class="back-btn" id="backToAnalysis">← 뒤로가기</button>
                <h1 id="detailTitle">상세 결과</h1>
            </div>
            <div id="detailsGrid" class="result-grid"></div>
        </div>

        <!-- 화면 4: 분석 기록 -->
        <div id="view-history" class="view scroll-view">
            <div class="header-row"><h1>과거 분석 기록</h1></div>
            <div id="historyGrid" class="result-grid"></div>
        </div>
    </div>

<script>
    /** 공통 시스템 연산 **/
    function getDigitSum(n) { return n.toString().split('').reduce((acc, char) => acc + BigInt(char), 0n); }
    function toBaseBString(n, b) {
        if (b <= 1n) return n.toString();
        let digits = []; let tempN = n;
        while (tempN > 0n) { digits.push(tempN % b); tempN = tempN / b; }
        return digits.reverse().join('') || "0";
    }
    function getNextState(n) { const b = getDigitSum(n); return { value: n, b, next: BigInt(toBaseBString(n, b)) }; }

    /** SPA 화면 전환 **/
    const views = { vis: document.getElementById('view-vis'), analysis: document.getElementById('view-analysis'), details: document.getElementById('view-details'), history: document.getElementById('view-history') };
    const navButtons = { vis: document.getElementById('nav-vis'), analysis: document.getElementById('nav-analysis'), history: document.getElementById('nav-history') };

    function switchView(target) {
        Object.values(views).forEach(v => v.classList.remove('active'));
        Object.values(navButtons).forEach(b => b.classList.remove('active'));
        views[target].classList.add('active');
        if (navButtons[target]) navButtons[target].classList.add('active');
        if (target === 'vis') startVisAnimation(); else stopVisAnimation();
        if (target === 'history') renderHistory();
    }
    Object.keys(navButtons).forEach(key => navButtons[key].addEventListener('click', () => switchView(key)));
    document.getElementById('backToAnalysis').addEventListener('click', () => switchView('analysis'));

    /** [화면 1] 시각화 로직 **/
    const gCanvas = document.getElementById('graphCanvas'); const gCtx = gCanvas.getContext('2d');
    const NODE_RADIUS = 30; // 사용자가 만족한 적절한 크기
    let nodes = [], edges = [], selectedNode = null, draggedNode = null, animationId = null, simulationAlpha = 1.0;

    function generateGraphData() {
        nodes = []; edges = []; simulationAlpha = 1.0; selectedNode = null;
        document.getElementById('info-panel').style.display = 'none';
        const startN = BigInt(document.getElementById('startN').value.trim() || "0"), maxIter = parseInt(document.getElementById('maxIter').value);
        let currentN = startN; const visitedMap = new Map(), sequence = [];
        for (let i = 0; i < maxIter; i++) {
            if (visitedMap.has(currentN)) { markCycle(sequence, visitedMap.get(currentN)); break; }
            const state = getNextState(currentN); visitedMap.set(currentN, i); sequence.push(state);
            const node = { id: currentN.toString(), value: currentN, x: gCanvas.width/2+(Math.random()-0.5)*100, y: gCanvas.height/2+(Math.random()-0.5)*100, vx:0, vy:0, type:'normal', nextValue: state.next, b: state.b };
            if (state.value === state.next) node.type = 'fixed';
            nodes.push(node); edges.push({ source: currentN.toString(), target: state.next.toString() });
            if (node.type === 'fixed') break; currentN = state.next;
        }
    }
    function markCycle(seq, start) { for (let i = start; i < seq.length; i++) { const n = nodes.find(x => x.id === seq[i].value.toString()); if (n && n.type !== 'fixed') n.type = 'cycle'; } }
    function updatePhysics() {
        if (simulationAlpha < 0.005) return false;
        nodes.forEach((n1, i) => nodes.slice(i+1).forEach(n2 => {
            const dx = n2.x-n1.x, dy = n2.y-n1.y, d2 = dx*dx+dy*dy+0.1, d = Math.sqrt(d2), f = (5000*simulationAlpha)/d2;
            n1.vx -= (dx/d)*f; n1.vy -= (dy/d)*f; n2.vx += (dx/d)*f; n2.vy += (dy/d)*f;
        }));
        edges.forEach(e => {
            const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target);
            if (!s || !t || s === t) return;
            const dx = t.x-s.x, dy = t.y-s.y, d = Math.sqrt(dx*dx+dy*dy)||0.1, f = (d-160)*(0.08*simulationAlpha);
            s.vx += (dx/d)*f; s.vy += (dy/d)*f; t.vx -= (dx/d)*f; t.vy -= (dy/d)*f;
        });
        nodes.forEach(n => { if (n !== draggedNode) { n.vx += (gCanvas.width/2-n.x)*0.005*simulationAlpha; n.vy += (gCanvas.height/2-n.y)*0.005*simulationAlpha; n.vx *= 0.85; n.vy *= 0.85; n.x += n.vx; n.y += n.vy; } });
        simulationAlpha *= 0.99; return true;
    }
    function drawVis() {
        gCtx.clearRect(0,0,gCanvas.width,gCanvas.height); const moving = updatePhysics();
        edges.forEach(e => {
            const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target); if (!s || !t || s === t) return;
            const angle = Math.atan2(t.y-s.y, t.x-s.x), tx = t.x-NODE_RADIUS*Math.cos(angle), ty = t.y-NODE_RADIUS*Math.sin(angle), sx = s.x+NODE_RADIUS*Math.cos(angle), sy = s.y+NODE_RADIUS*Math.sin(angle);
            gCtx.beginPath(); gCtx.moveTo(sx,sy); gCtx.lineTo(tx,ty); gCtx.strokeStyle = 'rgba(100, 116, 139, 0.5)'; gCtx.lineWidth = 3; gCtx.stroke();
            gCtx.beginPath(); gCtx.moveTo(tx,ty); gCtx.lineTo(tx-15*Math.cos(angle-Math.PI/6), ty-15*Math.sin(angle-Math.PI/6)); gCtx.lineTo(tx-15*Math.cos(angle+Math.PI/6), ty-15*Math.sin(angle+Math.PI/6)); gCtx.closePath(); gCtx.fillStyle = 'rgba(100, 116, 139, 0.8)'; gCtx.fill();
        });
        const time = Date.now()/1000;
        nodes.forEach(n => {
            gCtx.save(); let color = '#3b82f6'; if (n.type === 'fixed') color = '#10b981'; else if (n.type === 'cycle') color = '#f59e0b';
            gCtx.shadowBlur = 15+Math.sin(time*3)*5; gCtx.shadowColor = color;
            let scale = (moving || draggedNode || n === selectedNode) ? 1.0 + Math.sin(time*4)*0.03 : 1.0;
            gCtx.beginPath(); gCtx.arc(n.x, n.y, NODE_RADIUS*scale, 0, Math.PI*2);
            if (selectedNode === n) { gCtx.strokeStyle = 'white'; gCtx.lineWidth = 4; gCtx.stroke(); }
            gCtx.fillStyle = color; gCtx.fill(); gCtx.shadowBlur = 0; gCtx.fillStyle = 'white'; gCtx.font = 'bold 12px monospace'; gCtx.textAlign = 'center';
            gCtx.fillText(n.id.length > 7 ? n.id.substring(0,6)+'..' : n.id, n.x, n.y+5); gCtx.restore();
        });
        if (moving || draggedNode) animationId = requestAnimationFrame(drawVis); else animationId = null;
    }
    function startVisAnimation() { if (!animationId) drawVis(); }
    function stopVisAnimation() { if (animationId) cancelAnimationFrame(animationId); animationId = null; }

    /** [화면 2, 3, 4] 범위 분석 및 기록 **/
    const aCanvas = document.getElementById('analysisCanvas'); const aCtx = aCanvas.getContext('2d');
    const aProgress = document.getElementById('analysis-progress');
    let fullResults = { fixed: [], cycle: [], divergent: [] };
    let historyRecords = JSON.parse(localStorage.getItem('numeral_sim_history') || '[]');
    let barRects = [];

    function classifyDetailed(startN, maxIter) {
        let current = startN; const history = []; const historySet = new Set();
        for (let i = 0; i < maxIter; i++) {
            const state = getNextState(current);
            if (state.next === current) return { startValue: startN, type: 'fixed', fixedPoint: current };
            if (historySet.has(state.next)) {
                const cycleArr = history.slice(history.indexOf(state.next)).concat(state.next);
                return { startValue: startN, type: 'cycle', cycleValues: cycleArr };
            }
            if (state.next.toString().length > 10000) return { startValue: startN, type: 'divergent', reason: '자릿수 10,000자 초과' };
            history.push(current); historySet.add(current); current = state.next;
        }
        return { startValue: startN, type: 'divergent', reason: '반복 횟수 제한 초과' };
    }

    async function runAnalysis() {
        const minStr = document.getElementById('minStart').value, maxStr = document.getElementById('maxStart').value;
        if (!minStr || !maxStr) return alert("시작값을 입력하세요.");
        const min = BigInt(minStr), max = BigInt(maxStr), iter = parseInt(document.getElementById('rangeIter').value);
        fullResults = { fixed: [], cycle: [], divergent: [] };
        const total = Number(max - min + 1n); let processed = 0, current = min;
        async function process() {
            for (let i = 0; i < 50 && current <= max; i++) {
                const res = classifyDetailed(current, iter);
                fullResults[res.type].push(res);
                current++; processed++;
            }
            aProgress.textContent = `진행률: ${Math.round((processed/total)*100)}% (${processed}/${total})`;
            drawBarChart();
            if (current <= max) setTimeout(process, 0); else { aProgress.textContent = `분석 완료 (총 ${total}개)`; saveToHistory(min, max, iter); }
        }
        process();
    }

    function saveToHistory(min, max, iter) {
        const cycleCount = fullResults.cycle.length;
        const avgCycleLen = cycleCount > 0 ? (fullResults.cycle.reduce((acc, cur) => acc + cur.cycleValues.length, 0) / cycleCount).toFixed(2) : 0;
        const divReasons = fullResults.divergent.reduce((acc, cur) => { acc[cur.reason] = (acc[cur.reason] || 0) + 1; return acc; }, {});
        const newRecord = { id: Date.now(), timestamp: new Date().toLocaleString(), range: `${min} ~ ${max}`, iter, counts: { fixed: fullResults.fixed.length, cycle: cycleCount, divergent: fullResults.divergent.length }, avgCycleLen, divReasons };
        historyRecords.unshift(newRecord); localStorage.setItem('numeral_sim_history', JSON.stringify(historyRecords));
    }

    function deleteRecord(id) {
        if (!confirm('이 기록을 삭제하시겠습니까?')) return;
        historyRecords = historyRecords.filter(r => r.id !== id); localStorage.setItem('numeral_sim_history', JSON.stringify(historyRecords)); renderHistory();
    }

    function drawBarChart() {
        const r = aCanvas.parentElement.getBoundingClientRect(); aCanvas.width = r.width; aCanvas.height = r.height;
        aCtx.clearRect(0,0,aCanvas.width,aCanvas.height); barRects = [];
        const cats = [ {key:'fixed', label:'Fixed Point', color:'#10b981'}, {key:'cycle', label:'Cycle', color:'#f59e0b'}, {key:'divergent', label:'Divergent', color:'#ef4444'} ];
        const maxCount = Math.max(...cats.map(c => fullResults[c.key].length), 1);
        cats.forEach((cat, i) => {
            const count = fullResults[cat.key].length;
            const h = (count/maxCount)*(aCanvas.height*0.6), w = aCanvas.width*0.15, x = (aCanvas.width/4)*(i+1)-w/2, y = aCanvas.height*0.8-h;
            aCtx.fillStyle = cat.color; aCtx.fillRect(x, y, w, h);
            aCtx.fillStyle = 'white'; aCtx.font = 'bold 1.2rem Pretendard'; aCtx.textAlign = 'center'; aCtx.fillText(count, x+w/2, y-15);
            const labelY = aCanvas.height * 0.8 + 35; aCtx.fillStyle = cat.color; aCtx.fillText(cat.label, x+w/2, labelY);
            const textWidth = aCtx.measureText(cat.label).width;
            barRects.push({ x: x + w/2 - textWidth/2 - 20, y: labelY - 25, w: textWidth + 40, h: 40, key: cat.key });
            aCtx.beginPath(); aCtx.moveTo(x+w/2-textWidth/2, labelY+5); aCtx.lineTo(x+w/2+textWidth/2, labelY+5); aCtx.strokeStyle = cat.color; aCtx.lineWidth = 2; aCtx.stroke();
        });
    }

    function renderHistory() {
        const grid = document.getElementById('historyGrid');
        grid.innerHTML = historyRecords.length === 0 ? '<p style="grid-column: 1/-1; text-align: center; color: #94a3b8;">아직 기록된 분석이 없습니다.</p>' : '';
        historyRecords.forEach(rec => {
            const card = document.createElement('div'); card.className = 'result-card history-card';
            let divReasonHtml = Object.entries(rec.divReasons).map(([r, c]) => `<li>${r}: ${c}건</li>`).join('');
            const delBtn = document.createElement('button'); delBtn.className = 'delete-btn'; delBtn.textContent = '삭제'; delBtn.onclick = (e) => { e.stopPropagation(); deleteRecord(rec.id); };
            card.innerHTML = `<span class="stat-label">${rec.timestamp}</span><h4>범위: ${rec.range}</h4><p>최대 반복: ${rec.iter}회</p><div class="history-summary"><div class="summary-item"><span class="stat-label">Fixed</span><span class="num" style="color:var(--fixed)">${rec.counts.fixed}</span></div><div class="summary-item"><span class="stat-label">Cycle</span><span class="num" style="color:var(--cycle)">${rec.counts.cycle}</span></div><div class="summary-item"><span class="stat-label">Divergent</span><span class="num" style="color:var(--divergent)">${rec.counts.divergent}</span></div></div><div style="margin-top: 1rem; font-size: 0.9rem;"><p><b>평균 주기 길이:</b> ${rec.avgCycleLen}</p><p><b>발산 사유:</b></p><ul style="margin: 0; padding-left: 1.2rem; color: #94a3b8;">${divReasonHtml || '없음'}</ul></div>`;
            card.appendChild(delBtn); grid.appendChild(card);
        });
    }

    function showDetails(categoryKey) {
        const data = fullResults[categoryKey];
        const titleMap = { fixed: 'Fixed Point 목록', cycle: 'Cycle 목록', divergent: 'Divergent 목록' };
        document.getElementById('detailTitle').textContent = titleMap[categoryKey];
        const grid = document.getElementById('detailsGrid'); grid.innerHTML = '';
        data.forEach(item => {
            const card = document.createElement('div'); card.className = `result-card ${item.type}`;
            let extra = item.type === 'fixed' ? `<p>최종 고정점: <span class="val">${item.fixedPoint}</span></p>` : item.type === 'cycle' ? `<p>주기 길이: ${item.cycleValues.length}</p><p>구성: <span class="val">${item.cycleValues.join(', ')}</span></p>` : `<p>사유: <span style="color:var(--divergent)">${item.reason}</span></p>`;
            card.innerHTML = `<h4>시작값: ${item.startValue}</h4>${extra}`; grid.appendChild(card);
        });
        switchView('details');
    }

    aCanvas.addEventListener('mousedown', (e) => {
        const rect = aCanvas.getBoundingClientRect(), mx = e.clientX-rect.left, my = e.clientY-rect.top;
        const hit = barRects.find(b => mx >= b.x && mx <= b.x+b.w && my >= b.y && my <= b.y+b.h);
        if (hit) showDetails(hit.key);
    });

    /** 인터랙션: 클릭 시 상세 정보 표시 복구 및 드래그 **/
    gCanvas.addEventListener('mousedown', (e) => {
        const rect = gCanvas.getBoundingClientRect(), mx = e.clientX-rect.left, my = e.clientY-rect.top;
        const found = nodes.find(n => Math.sqrt((n.x-mx)**2+(n.y-my)**2) < NODE_RADIUS + 10); // 클릭 반경 보정
        if (found) {
            draggedNode = found; selectedNode = found; simulationAlpha = 0.5;
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('node-details').innerHTML = `<b>값:</b> ${found.value}<br><b>진법 b:</b> ${found.b}<br><b>다음값:</b> ${found.nextValue}`;
            startVisAnimation();
        } else { selectedNode = null; document.getElementById('info-panel').style.display = 'none'; }
    });
    window.addEventListener('mousemove', (e) => { if (draggedNode) { const r = gCanvas.getBoundingClientRect(); draggedNode.x = e.clientX-r.left; draggedNode.y = e.clientY-r.top; simulationAlpha = 0.2; } });
    window.addEventListener('mouseup', () => draggedNode = null);

    /** 초기화 **/
    document.getElementById('runBtn').addEventListener('click', () => { generateGraphData(); startVisAnimation(); });
    document.getElementById('analysisBtn').addEventListener('click', runAnalysis);
    window.addEventListener('resize', () => { drawBarChart(); const r = gCanvas.parentElement.getBoundingClientRect(); gCanvas.width=r.width; gCanvas.height=r.height; });
    window.onload = () => { window.dispatchEvent(new Event('resize')); generateGraphData(); startVisAnimation(); };
</script>
</body>
</html>
